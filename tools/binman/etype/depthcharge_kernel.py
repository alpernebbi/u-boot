# SPDX-License-Identifier: GPL-2.0+
# Copyright (c) Alper Nebi Yasak <alpernebiyasak@gmail.com>
#
# Based on existing binman code:
#   Copyright (c) Google, Inc
#   Written by Simon Glass <sjg@chromium.org>

# Support for a Chromium OS verified boot kernel partition.

from binman.entry import Entry, EntryArg
from binman.etype.section import Entry_section

from u_boot_pylib import tools

class Entry_depthcharge_kernel(Entry_section):
    """Entry containing a Chromium OS kernel partition image

    Chromium OS packs and signs its kernel, config and a bootloader stub
    into a custom format and writes it to a GPT partition, which allows
    the Chromium OS bootloader ("Depthcharge") to verify the kernel and
    its parameters before booting it. This entry calls Chromium OS'
    futility tool to create this kind of 'kernel' based on the inputs
    provided.

    For example:

        binman {
            depthcharge-kernel {
                keydir = "/usr/share/vboot/devkeys";
                keyblock = "kernel.keyblock";
                signprivate = "kernel_data_key.vbprivk";
                version = <1>;
                preamble-flags = <0>;
                arch = "arm";

                vmlinuz {
                    u-boot {
                    };
                };

                config {
                    text {
                        text = "kern_guid=%U";
                    };
                };

                bootloader {
                    fill {
                        size = <512>;
                    };
                };
            };
        };

    Properties / Entry arguments:
        - keydir: Directory containing the public keys to use
        - keyblock: Name of the key file to use (inside keydir)
        - signprivate: Name of provide key file to use (inside keydir)
        - version: Version number of the vblock (typically 1)
        - arch: Cpu architecture (x86, amd64, arm, aarch64, mips)

    Optional properties / arguments:
        - preamble-flags: Value of the vboot preamble flags (typically 0)
        - kloadaddr: RAM address to load the kernel body (optional)
        - vblock-pad: Vblock padding size (optional)

    Subsections:
        - vmlinuz: The kernel to sign and pack (typically a FIT image
          on arm architectures)
        - config: The kernel commandline file, at most 4095 bytes. If
          not given, an empty file is used.
        - bootloader: "Bootloader stub". If not given, an empty file is
          used.

    Output files:
        - <unique_name>.vmlinuz - input vmlinuz file passed to futility
        - <unique_name>.config - input config file passed to futility
        - <unique_name>.booloader - input bootloader file passed to futility
        - <unique_name>.kpart - output file generated by futility (which is
            used as the entry contents)
    """
    def __init__(self, section, etype, node):
        # Put this here to allow entry-docs and help to work without libfdt
        global state
        from binman import state

        super().__init__(section, etype, node)

        self.futility = None

    def ReadNode(self):
        """Read properties from the depthcharge-kernel node"""
        super().ReadNode()

        (self.keydir, self.keyblock, self.signprivate, self.version,
         self.preamble_flags, self.arch, self.kloadaddr, self.vblock_pad,
        ) = self.GetEntryArgsOrProps([
            EntryArg('keydir', str),
            EntryArg('keyblock', str),
            EntryArg('signprivate', str),
            EntryArg('version', int),
            EntryArg('preamble-flags', int),
            EntryArg('arch', str),
            EntryArg('kloadaddr', int),
            EntryArg('vblock-pad', int),
        ])

        self.ReadEntries()

    def ReadEntries(self):
        """Read subentries of the depthcharge-kernel node"""
        for node in self._node.subnodes:
            if node.name not in ('vmlinuz', 'config', 'bootloader'):
                self._Raise("Can't have a %s subsection" % node.name)
            if node.name in self._entries:
                continue

            entry = Entry.Create(self, node, etype="section",
                                 expanded=self.GetImage().use_expanded,
                                 missing_etype=self.GetImage().missing_etype)
            entry.ReadNode()
            entry.SetPrefix(self._name_prefix)
            self._entries[node.name] = entry

        if 'vmlinuz' not in self._entries:
            self._Raise("Must have a vmlinuz subsection")

    def gen_entries(self):
        """Add dummy entries for required config, bootloader subsections

         The futility vbutil_kernel command raises an error if any of
         its 'config' or 'bootloader' are missing or empty files, but
         they are not necessarily important for us. This tries to make
         them optional in the binman specification by creating dummy
         sections if they're missing.
        """
        super().gen_entries()

        for name in ('config', 'bootloader'):
            subsection = self._node.FindNode(name)
            if not subsection:
                subsection = state.AddSubnode(self._node, name)
                subnode = state.AddSubnode(subsection, "fill")
                state.AddInt(subnode, 'size', 0xfff)

        # Read entries again, now that we have more
        self.ReadEntries()

    def BuildSectionData(self, required):
        """Build Depthcharge kernel entry contents

        This writes the input subentry contents to files, then runs futility
        vbutil_kernel to sign and package them into the required format.

        Args:
            required: True if the data must be present, False if it is OK to
                return None

        Returns:
            Contents of the section (bytes)
        """
        uniq = self.GetUniqueName()

        vmlinuz_fname = tools.get_output_filename('%s.vmlinuz' % uniq)
        config_fname = tools.get_output_filename('%s.config' % uniq)
        bootloader_fname = tools.get_output_filename('%s.bootloader' % uniq)

        vmlinuz = self._entries['vmlinuz'].GetData()
        config = self._entries['config'].GetData()
        bootloader = self._entries['bootloader'].GetData()

        if not required:
            if not all(data for data in (vmlinuz, config, bootloader)):
                return None

        tools.write_file(vmlinuz_fname, vmlinuz)
        tools.write_file(config_fname, config)
        tools.write_file(bootloader_fname, bootloader)

        output_fname = tools.get_output_filename('%s.kpart' % uniq)
        prefix = tools.get_input_filename(self.keydir) + '/'

        stdout = self.futility.pack_kernel(
            kpart=output_fname,
            keyblock=prefix + self.keyblock,
            signprivate=prefix + self.signprivate,
            version=self.preamble_flags,
            vmlinuz=vmlinuz_fname,
            bootloader=bootloader_fname,
            config=config_fname,
            arch=self.arch,
            kloadaddr=self.kloadaddr,
            pad=self.vblock_pad,
            vblockonly=False,
            flags=self.preamble_flags,
        )
        if stdout is not None:
            data = tools.read_file(output_fname)
        else:
            # Bintool is missing; just use 4KB of zero data
            self.record_missing_bintool(self.futility)
            data = tools.get_bytes(0, 4096)

        return data

    def SetImagePos(self, image_pos):
        """Set the position in the image

        This sets each subentry's offsets, sizes and positions-in-image
        according to where they ended up in the packed Depthcharge
        kernel file.

        Args:
            image_pos: Position of this entry in the image
        """
        super().SetImagePos(image_pos)

        vmlinuz = self._entries["vmlinuz"]
        config = self._entries["config"]
        bootloader = self._entries["bootloader"]

        # The default here is from vbutil_kernel
        vblock_pad = self.vblock_pad or 0x10000

        def find_aligned(data, start=0, align=0x1000):
            start = tools.align(start, align)
            pos = self.data.find(data, start)
            while pos > start:
                start = tools.align(pos, align)
                pos = self.data.find(data, start)
            return pos

        # Let's ignore the things vbutil_kernel does to a x86 Linux kernel
        # to avoid reimplementing vboot_reference in python for now...
        offset = vblock_pad
        vmlinuz_offset = find_aligned(vmlinuz.data, offset)
        if vmlinuz_offset == -1:
            self.Detail("Can't find vmlinuz data in Depthcharge kernel")
        else:
            vmlinuz.SetOffsetSize(vmlinuz_offset, len(vmlinuz.data))
            vmlinuz.SetImagePos(image_pos)

        # Newlines in 'config' are replaced with spaces
        offset = vmlinuz_offset + len(vmlinuz.data)
        config_data = config.data.replace(b"\n", b" ")
        config_offset = find_aligned(config_data, offset)
        if config_offset == -1:
            self.Detail("Can't find config data in Depthcharge kernel")
        else:
            config.SetOffsetSize(config_offset, len(config.data))
            config.SetImagePos(image_pos)

        # 'bootloader' is untouched. 'config' size is actually fixed to
        # 0x1000, but there's another 0x1000 region before 'bootloader'
        # (zeropage for x86 Linux kernel)
        offset = config_offset + 0x2000
        bootloader_offset = find_aligned(bootloader.data, offset)
        if bootloader_offset == -1:
            self.Detail("Can't find bootloader data in Depthcharge kernel")
        else:
            bootloader.SetOffsetSize(bootloader_offset, len(bootloader.data))
            bootloader.SetImagePos(image_pos)

    def ProcessContents(self):
        # The blob may have changed due to WriteSymbols()
        data = self.BuildSectionData(True)
        return self.ProcessContentsUpdate(data)

    def AddBintools(self, tools):
        super().AddBintools(tools)
        self.futility = self.AddBintool(tools, 'futility')
